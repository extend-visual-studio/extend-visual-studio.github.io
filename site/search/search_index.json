{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This site, extendvs.com, has a simple mission: to expand the public knowledge based for building extensions for Visual Studio Windows and Mac. wwww.extendvs.com is an open source and MIT licensed site; please contribute and help grow the knowledge base for Visual Studio extensibility. Getting Started Setup your environment for extension development and write your first extension. Getting Started with Visual Studio Windows Extensions. Getting Started with Visual Studio Mac Extensions. Api Overview An overview of the common concepts and APIs in Visual Studio extensibility. Samples The accompanying samples for this site. Tools Useful tools to assist you when developing Visual Studio extensions. Visual Studio Windows Tools. Visual Studio Mac Tools. Gallery A gallery of open source extensions including an overview of the core concepts they demonstrate. Visual Studio Windows Gallery. Visual Studio Mac Gallery. Glossary A glossary of core terminology for Visual Studio extension development","title":"Home"},{"location":"#welcome","text":"This site, extendvs.com, has a simple mission: to expand the public knowledge based for building extensions for Visual Studio Windows and Mac. wwww.extendvs.com is an open source and MIT licensed site; please contribute and help grow the knowledge base for Visual Studio extensibility.","title":"Welcome"},{"location":"#getting-started","text":"Setup your environment for extension development and write your first extension. Getting Started with Visual Studio Windows Extensions. Getting Started with Visual Studio Mac Extensions.","title":"Getting Started"},{"location":"#api-overview","text":"An overview of the common concepts and APIs in Visual Studio extensibility.","title":"Api Overview"},{"location":"#samples","text":"The accompanying samples for this site.","title":"Samples"},{"location":"#tools","text":"Useful tools to assist you when developing Visual Studio extensions. Visual Studio Windows Tools. Visual Studio Mac Tools.","title":"Tools"},{"location":"#gallery","text":"A gallery of open source extensions including an overview of the core concepts they demonstrate. Visual Studio Windows Gallery. Visual Studio Mac Gallery.","title":"Gallery"},{"location":"#glossary","text":"A glossary of core terminology for Visual Studio extension development","title":"Glossary"},{"location":"about-the-author/","text":"About The Author","title":"About The Author"},{"location":"about-the-author/#about-the-author","text":"","title":"About The Author"},{"location":"api-overview/","text":"A side by side comparison of the equivalent APIs in Visual Studio Windows vs Visual Studio Mac Overview This article provides an overview of the common concepts in an IDE extension and what the equivalent API/object is in the other IDE. Manifests The manifest declares the information about our extension such as its name, author, copyright, identifier and version number. Visual Studio Windows A Visual Studio Windows extension has the VSIX manifest and the command manifest. The VSIX manifest file ( extension.vsixmanifest ) defines the information about your extension such as name, author, version number and more. See here for documentation. The Visual Studio Command Table ( .vsct ) defines the commands that your package contains. See here for documentation. Visual Studio Mac A Visual Studio Mac extension includes a file named Manifest.addin.xml that defines the extension points To declare the name, author, copyright, version etc of an extension, we use the following attributes: Package The package is the central class that represents our extension and exposes it to the IDE. Visual Studio Windows We implement the AsyncPackage class to declare the core of our extension. See here for documentation. Visual Studio Mac Visual Studio Mac does not have the concept of a core package class. Startup For both Visual Studio Windows and Mac, extensions by default do not have a defined entry point. Extensions do not receive startup notifications by default and should be design so that they do not rely on a startup sequence. Visual Studio Windows To detect the startup of our extension in Visual Studio Windows, we register the loading of our package against a specified IDE event using the ProvideAutoLoad attribute attached to our Package. See here for documentation . Avoid relying on any form of startup event to initialise your Visual Studio Windows extension. The modern Visual Studio APIs (such as IntelliSense or adornments) and Roslyn APIs load feature implementations outside of Visual Studio Mac To detect the startup of our extension on Visual Studio Mac, we add a new CommandHandler to the /MonoDevelop/Ide/StartupHandlers extension point. IDE Application The IDE application is the root access point for most of the major APIs we would use in our extension. Visual Studio Windows In Visual Studio Windows the root IDE/application object is the DTE . Importantly, the DTE also has the DTE2 interface that exposes many additional APIs. Visual Studio Mac In Visual Studio Mac, the root IDE/application object is the IdeApp . Service Locator The service locator is used to retrieve service implementations through a central access class. Visual Studio Windows In Visual Studio Windows, the service locator is the ServiceProvider class. Below is an example of retrieving a service using the ServiceProvider : var dte = ServiceProvider . GlobalProvider . GetService ( typeof ( DTE )) as DTE2 ; Visual Studio Mac Visual Studio Mac does not have a service locator. To access core services: Use the static IdeServices to access core services like the ProjectService, TypeSystemService, DesktopService etc. Use the CompositionManager to access parts that have been exported to MEF. Use the IdeApp to access the core services such as the Workspace, Workbench MEF Export Provider The export provider is used to retrieve parts that are exported to the Managed Extensibility Framework . Visual Studio Windows We can access the export provider on Windows with the following code: var componentModel = ( IComponentModel ) Package . GetGlobalService ( typeof ( SComponentModel )); var exportProvder = componentModel . DefaultExportProvider ; Visual Studio Mac We can access the MEF composition manager on Mac with the following code: MonoDevelop . Ide . Composition . CompositionManager . Instance . ExportProvider ; Commands Visual Studio Windows In Visual Studio Windows we declare command elements in a vsct file and register new commands using the OleMenuCommandService . See here for documentation. Visual Studio Mac In Visual Studio Mac we create CommandHandler sub-classes and then connect that command instance into an extension point using the Manifest.addin.xml file. See here for documentation. Active Documents The list of active, opened documents, also known as the running documents table, describe the documents that are currently open and have a source code editor user interface. Visual Studio Windows In Visual Studio Windows, we can the DTE2.Documents property to access the currently open documents. To subscribe to document open/closed/modified events, we can use the DTE2.Events.DocumentEvents property. Visual Studio Mac In Visual Studio Mac, we can use the TypeSystemService.DocumentManager to query the currently opened documents and subscribe to open/closed/modified events. Workspace Model In IDE extensions we have the concept of a workspace model , that is, the hierarchical relationship of a solution, its projects and the files and references of those projects. The workspace model is different to the compilation model as it incorporates project assets (like images or embedded resources), packages etc into the model. The workspace model is akin to what is displayed in the Solution Explorer, whereas the compilation model only contains information required to generate an executable. Visual Studio Windows Visual Studio Mac Workspace Events Pads Pads are visual items that can be detached and moved around the IDE application. Visual Studio Windows In Visual Studio Windows, Pads are known as Tool Windows . To create one, we sub-class ToolWindowPane and add the [ProvideToolWindow(typeof(MyToolWindow))] attribute to our AsyncPackage to expose a new tool window. Visual Studio Mac In Visual Studio Mac, we implement the PadContent class and then present it using the IdeApp.Workbench.ShowPad method. Solution Pad/Explorer The solution explorer enables developers to visually explore the contents of the workspace model. It is presented as a tree-view in a detachable pad/tool window. As extension developers, we may need to inspect the solution explorer to: Understand what the currently selected item is (such as a project, file or solution). Connect Visual Studio Windows In Visual Studio Windows we can access the solution explorer using the DTE.ToolWindows.SolutionExplorer API. Visual Studio In Visual Studio Mac we can access the solution explorer using the IdeApp.ProjectOperations API.","title":"API Overview"},{"location":"api-overview/#overview","text":"This article provides an overview of the common concepts in an IDE extension and what the equivalent API/object is in the other IDE.","title":"Overview"},{"location":"api-overview/#manifests","text":"The manifest declares the information about our extension such as its name, author, copyright, identifier and version number. Visual Studio Windows A Visual Studio Windows extension has the VSIX manifest and the command manifest. The VSIX manifest file ( extension.vsixmanifest ) defines the information about your extension such as name, author, version number and more. See here for documentation. The Visual Studio Command Table ( .vsct ) defines the commands that your package contains. See here for documentation. Visual Studio Mac A Visual Studio Mac extension includes a file named Manifest.addin.xml that defines the extension points To declare the name, author, copyright, version etc of an extension, we use the following attributes:","title":"Manifests"},{"location":"api-overview/#package","text":"The package is the central class that represents our extension and exposes it to the IDE. Visual Studio Windows We implement the AsyncPackage class to declare the core of our extension. See here for documentation. Visual Studio Mac Visual Studio Mac does not have the concept of a core package class.","title":"Package"},{"location":"api-overview/#startup","text":"For both Visual Studio Windows and Mac, extensions by default do not have a defined entry point. Extensions do not receive startup notifications by default and should be design so that they do not rely on a startup sequence. Visual Studio Windows To detect the startup of our extension in Visual Studio Windows, we register the loading of our package against a specified IDE event using the ProvideAutoLoad attribute attached to our Package. See here for documentation . Avoid relying on any form of startup event to initialise your Visual Studio Windows extension. The modern Visual Studio APIs (such as IntelliSense or adornments) and Roslyn APIs load feature implementations outside of Visual Studio Mac To detect the startup of our extension on Visual Studio Mac, we add a new CommandHandler to the /MonoDevelop/Ide/StartupHandlers extension point.","title":"Startup"},{"location":"api-overview/#ide-application","text":"The IDE application is the root access point for most of the major APIs we would use in our extension. Visual Studio Windows In Visual Studio Windows the root IDE/application object is the DTE . Importantly, the DTE also has the DTE2 interface that exposes many additional APIs. Visual Studio Mac In Visual Studio Mac, the root IDE/application object is the IdeApp .","title":"IDE Application"},{"location":"api-overview/#service-locator","text":"The service locator is used to retrieve service implementations through a central access class. Visual Studio Windows In Visual Studio Windows, the service locator is the ServiceProvider class. Below is an example of retrieving a service using the ServiceProvider : var dte = ServiceProvider . GlobalProvider . GetService ( typeof ( DTE )) as DTE2 ; Visual Studio Mac Visual Studio Mac does not have a service locator. To access core services: Use the static IdeServices to access core services like the ProjectService, TypeSystemService, DesktopService etc. Use the CompositionManager to access parts that have been exported to MEF. Use the IdeApp to access the core services such as the Workspace, Workbench","title":"Service Locator"},{"location":"api-overview/#mef-export-provider","text":"The export provider is used to retrieve parts that are exported to the Managed Extensibility Framework . Visual Studio Windows We can access the export provider on Windows with the following code: var componentModel = ( IComponentModel ) Package . GetGlobalService ( typeof ( SComponentModel )); var exportProvder = componentModel . DefaultExportProvider ; Visual Studio Mac We can access the MEF composition manager on Mac with the following code: MonoDevelop . Ide . Composition . CompositionManager . Instance . ExportProvider ;","title":"MEF Export Provider"},{"location":"api-overview/#commands","text":"Visual Studio Windows In Visual Studio Windows we declare command elements in a vsct file and register new commands using the OleMenuCommandService . See here for documentation. Visual Studio Mac In Visual Studio Mac we create CommandHandler sub-classes and then connect that command instance into an extension point using the Manifest.addin.xml file. See here for documentation.","title":"Commands"},{"location":"api-overview/#active-documents","text":"The list of active, opened documents, also known as the running documents table, describe the documents that are currently open and have a source code editor user interface. Visual Studio Windows In Visual Studio Windows, we can the DTE2.Documents property to access the currently open documents. To subscribe to document open/closed/modified events, we can use the DTE2.Events.DocumentEvents property. Visual Studio Mac In Visual Studio Mac, we can use the TypeSystemService.DocumentManager to query the currently opened documents and subscribe to open/closed/modified events.","title":"Active Documents"},{"location":"api-overview/#workspace-model","text":"In IDE extensions we have the concept of a workspace model , that is, the hierarchical relationship of a solution, its projects and the files and references of those projects. The workspace model is different to the compilation model as it incorporates project assets (like images or embedded resources), packages etc into the model. The workspace model is akin to what is displayed in the Solution Explorer, whereas the compilation model only contains information required to generate an executable. Visual Studio Windows Visual Studio Mac","title":"Workspace Model"},{"location":"api-overview/#workspace-events","text":"","title":"Workspace Events"},{"location":"api-overview/#pads","text":"Pads are visual items that can be detached and moved around the IDE application. Visual Studio Windows In Visual Studio Windows, Pads are known as Tool Windows . To create one, we sub-class ToolWindowPane and add the [ProvideToolWindow(typeof(MyToolWindow))] attribute to our AsyncPackage to expose a new tool window. Visual Studio Mac In Visual Studio Mac, we implement the PadContent class and then present it using the IdeApp.Workbench.ShowPad method.","title":"Pads"},{"location":"api-overview/#solution-padexplorer","text":"The solution explorer enables developers to visually explore the contents of the workspace model. It is presented as a tree-view in a detachable pad/tool window. As extension developers, we may need to inspect the solution explorer to: Understand what the currently selected item is (such as a project, file or solution). Connect Visual Studio Windows In Visual Studio Windows we can access the solution explorer using the DTE.ToolWindows.SolutionExplorer API. Visual Studio In Visual Studio Mac we can access the solution explorer using the IdeApp.ProjectOperations API.","title":"Solution Pad/Explorer"},{"location":"glossary/","text":"A glossary of core terminology for Visual Studio extension development Common Terminology Integrated Development Environment (IDE) An application for software developers that provides code editing, debugging and compilation features. Inversion Of Control (IOC) Dependency Injection (DI) Visual Studio Windows Visual Studio Mac Roslyn Managed Extensibility Framework Managed Extensibility Framework (MEF) A library for creating lightweight, extensible applications. MEF is an Inversion Of Control framework that provides component/part management and dependency injection and is the backing IOC technology for the Visual Studio family. See here for documentation . Part An object exported to MEF through the Export attribute. Parts can be considered as components that are managed by MEF.","title":"Glossary"},{"location":"glossary/#common-terminology","text":"","title":"Common Terminology"},{"location":"glossary/#integrated-development-environment-ide","text":"An application for software developers that provides code editing, debugging and compilation features.","title":"Integrated Development Environment (IDE)"},{"location":"glossary/#inversion-of-control-ioc","text":"","title":"Inversion Of Control (IOC)"},{"location":"glossary/#dependency-injection-di","text":"","title":"Dependency Injection (DI)"},{"location":"glossary/#visual-studio-windows","text":"","title":"Visual Studio Windows"},{"location":"glossary/#visual-studio-mac","text":"","title":"Visual Studio Mac"},{"location":"glossary/#roslyn","text":"","title":"Roslyn"},{"location":"glossary/#managed-extensibility-framework","text":"","title":"Managed Extensibility Framework"},{"location":"glossary/#managed-extensibility-framework-mef","text":"A library for creating lightweight, extensible applications. MEF is an Inversion Of Control framework that provides component/part management and dependency injection and is the backing IOC technology for the Visual Studio family. See here for documentation .","title":"Managed Extensibility Framework (MEF)"},{"location":"glossary/#part","text":"An object exported to MEF through the Export attribute. Parts can be considered as components that are managed by MEF.","title":"Part"},{"location":"samples/","text":"","title":"Samples"},{"location":"gallery/visual-studio-mac/","text":"A showcase of open-source extensions for Visual Studio Mac AddinMaker Author: @mhutch URL: https://github.com/mhutch/MonoDevelop.AddinMaker AddinMaker makes it easy to create and maintain Visual Studio for Mac and MonoDevelop extensions. Concepts Demonstrated Commanding. XML IntelliSense via BaseXmlEditorExtension. File templates. Custom Pads. Create a custom UI (using XWT) Custom project types. SkiaFiddle Author : Javier Su\u00e1rez URL : https://github.com/matthewrdev/VS4Mac-SkiaSharpFiddle SkiaSharp Fiddle is a SkiaSharp playground - just like https://fiddle.skia.org, but inside VS4Mac! Concepts Demonstrated Create a pad. Create a custom UI (using XWT) Rolsyn for code analysis. UnitTestGenerator Author : @dlmcdonald URL : https://github.com/dlmcdonald/UnitTestGenerator Visual Studio for Mac extension to generate NUnit unit tests from any method. Concepts Demonstrated Commanding. Managed Extensibility Framework. Code generation using Roslyn.","title":"Mac"},{"location":"gallery/visual-studio-mac/#addinmaker","text":"Author: @mhutch URL: https://github.com/mhutch/MonoDevelop.AddinMaker AddinMaker makes it easy to create and maintain Visual Studio for Mac and MonoDevelop extensions. Concepts Demonstrated Commanding. XML IntelliSense via BaseXmlEditorExtension. File templates. Custom Pads. Create a custom UI (using XWT) Custom project types.","title":"AddinMaker"},{"location":"gallery/visual-studio-mac/#skiafiddle","text":"Author : Javier Su\u00e1rez URL : https://github.com/matthewrdev/VS4Mac-SkiaSharpFiddle SkiaSharp Fiddle is a SkiaSharp playground - just like https://fiddle.skia.org, but inside VS4Mac! Concepts Demonstrated Create a pad. Create a custom UI (using XWT) Rolsyn for code analysis.","title":"SkiaFiddle"},{"location":"gallery/visual-studio-mac/#unittestgenerator","text":"Author : @dlmcdonald URL : https://github.com/dlmcdonald/UnitTestGenerator Visual Studio for Mac extension to generate NUnit unit tests from any method. Concepts Demonstrated Commanding. Managed Extensibility Framework. Code generation using Roslyn.","title":"UnitTestGenerator"},{"location":"gallery/visual-studio-windows/","text":"A showcase of open-source extensions for Visual Studio Windows Visual Studio Extensibility Samples Author: @microsoft URL: https://github.com/microsoft/VSSDK-Extensibility-Samples The official Microsoft Visual Studio Windows extensibility samples. Concepts Demonstrated Commanding. IntelliSense. Text Adornments. Tooltips. Solution Events. User Preferences. Tool Windows. Managed Extensibility framework. Using the DTE. Using the ServiceProvider.","title":"Windows"},{"location":"gallery/visual-studio-windows/#visual-studio-extensibility-samples","text":"Author: @microsoft URL: https://github.com/microsoft/VSSDK-Extensibility-Samples The official Microsoft Visual Studio Windows extensibility samples. Concepts Demonstrated Commanding. IntelliSense. Text Adornments. Tooltips. Solution Events. User Preferences. Tool Windows. Managed Extensibility framework. Using the DTE. Using the ServiceProvider.","title":"Visual Studio Extensibility Samples"},{"location":"getting-started/visual-studio-mac/","text":"Setting up your environment and writing your first Visual Studio Mac extension","title":"Mac"},{"location":"getting-started/visual-studio-windows/","text":"Setting up your environment and writing your first Visual Studio Windows extension","title":"Windows"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/","text":"Exposing your Visual Studio Mac extension to MEF Sample Code Overview This article assumes a thorough knowledge of the inversion of control and dependency injection principles. MEF Registration Add System.ComponentModel.Composition NuGet Add Assembly To MEF Catalog Exporting A Part Retrieving Parts Using CompositionManager","title":"MEF In Visual Studio Mac"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/#overview","text":"This article assumes a thorough knowledge of the inversion of control and dependency injection principles.","title":"Overview"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/#mef-registration","text":"","title":"MEF Registration"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/#add-systemcomponentmodelcomposition-nuget","text":"","title":"Add System.ComponentModel.Composition NuGet"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/#add-assembly-to-mef-catalog","text":"","title":"Add Assembly To MEF Catalog"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/#exporting-a-part","text":"","title":"Exporting A Part"},{"location":"managed-extensibility-framework/mef-visual-studio-mac/#retrieving-parts-using-compositionmanager","text":"","title":"Retrieving Parts Using CompositionManager"},{"location":"tools/visual-studio-mac/","text":"Useful tools to assist you when developing Visual Studio Mac extensions AddinMaker AddinMaker makes it easy to create and maintain Visual Studio for Mac and MonoDevelop extensions. Features Full support for creating, building, running and debugging addins from within MD/XS. MSBuild-based build system is extensible and allows building from the commandline. Code completion for addin manifests, file templates and project templates. Automatically handles referencing core MD/XS assemblies and assemblies from referenced addins. The AddinFile build action takes care of the details of bundling files with the addin. Multi-targeting support allows building against any MD/XS instance.","title":"Mac"},{"location":"tools/visual-studio-mac/#addinmaker","text":"AddinMaker makes it easy to create and maintain Visual Studio for Mac and MonoDevelop extensions. Features Full support for creating, building, running and debugging addins from within MD/XS. MSBuild-based build system is extensible and allows building from the commandline. Code completion for addin manifests, file templates and project templates. Automatically handles referencing core MD/XS assemblies and assemblies from referenced addins. The AddinFile build action takes care of the details of bundling files with the addin. Multi-targeting support allows building against any MD/XS instance.","title":"AddinMaker"},{"location":"tools/visual-studio-windows/","text":"","title":"Windows"}]}